Handle complex logic with useReducer

- [Instructor] When your app starts to grow, state management needs to be handled very effectively and separately. For that you can use another hook, useReducer, which is a good alternative to useState. So useReducer accepts two entries, first, the function reducer, and another one optional, which is the initialState. Then it returns an array with the current state and the dispatch method that we use to send actions to a function reducer, which is then in charge of returning a new state. And with the new state, we can then update the UI of the components. So let's go back to the source code and see how we can move the business logic and the state management in a separate location. For that, we're going to use useReducer that we're going to add to the scope of this component. Then we're going to write an instance of useReducer that takes two entries. So first the function reducer and the initial state. So we're going to write a new function reducer right here that we're going to implement later, and also a new object to define some initial states. So that's going to be first items, that's going to be equal to photos. Then accounts, which will be equal to photos length. Then the form inputs that we're going to set equal to this. And finally, is collapsed just to indicate if the form is visible or not. Here we go. And the useReducer then returns the current state and a dispatch function. So as a first demo, what we're going to do is first log out of the current state. We're going to see that this is correctly implemented so we're going to use a use effect to apply side effects when the component is loaded, meaning that we don't need to define anything in the list of dependencies. So we're going to log out the current state. Let's see. Here we go. You can see that now we have the current state as we have defined it. So next we want to see a demonstration of when we dispatch an action. So for that we're going to implement here the function reducer. That takes two parameters. So first the state and an action object, which allows to define the type of the action and the payload, meaning the information that we send along with an action. And the function of the function reducer is to return a new state when an action is sent. And that's going to be based on different use case scenarios. So for that, we're going to use some control flow and define a switch statement. And that's going to be based on the type of action. We're going to have different case scenarios that we're going to define right here. So we'll see one quick first example. And based on that, we're going to be able to return a new and updated state. By default, we also return the current state. So for example, we would like to define a new action, which is to allow to add a new element to the collection of photos. So we're going to first update with the current state, and then update the current collection of items with a new element. For example, it's going to be a new objects merged with the current state of items. So that's going to be actually right here, we're just going to put payload, and that's going to be actually action payload. So that's going to be from the action. So that's going to be sent along with the action. And for that first demo, I'm just going to use path. And we're going to dispatch these actions from here, so when we use set items and instead we're going to do dispatch and then define the type of the action, which should be the same as here, set item. And then to specify the information that we send along with this action, we're going to specify here the inputs, actually the path, which will be equals to inputs path for this first demo. And after that, we're going to allow as well to log out the current state, the new state. So as soon as this is done, when there is a change in the state. So let's try that. We're going to then add a new path. So I'm going to say new image. I'm going to upload, take a new image from the collection. Here you go. And then save change. And now we should see that we have the new items in the collection. So in order for it to be visible, we should actually refer to now state items. So I'm going to do that right here. And now we can see that, actually, we're going to need to make a few changes. I'm just going to leave this one as empty for now because we're not going to need those things afterwards. We're going to make a few changes. It's going to be photos and then photos path. Here we go. So I'm just going to refresh and make another quick test. For now it's just new image, new image. We're going to add another one, this one, and add to the gallery. Use producer is a preferred solution when the business logic of your app is starting to be more complex. The goal is to separate the logic from the presentation. So we decided to move the business logic in a separate function called Reducer that we're going to complete next, and then handle the state management separately in one location only.