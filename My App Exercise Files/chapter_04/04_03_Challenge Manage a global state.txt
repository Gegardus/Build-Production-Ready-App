Challenge: Manage a global state

- [Instructor] Let's complete the app by refactoring by using the hook useContext. The goal with this exercise is to learn to manage the state with one single source of truth. So we're going to do that by using another hook, which is useContext. That allows to share global state with components without doing any props drilling. So the way this works is that this useContext accepts one parameter, which is the context object, to return the current state value. Let me show you how. So what we've been doing so far is to use this setup with the component provider to pass data down to child components, by using this single prop, which is the value. So basically, what's going to help doing this useContext, is to take as a parameter this context object, to then return the global value, which is set up right here. So let me show you one quick example. We're going to go to the app components and I'm going to add to the scope of this app component the useContext. Here we go. And we're going to use this one inside the app component. So it's going to return the current state value, useContext, and remember that it's going to take also as a parameter, the context object. So I'm going to need to also use add to the scope, this context object. And I need to make sure that this is exported so I can use it outside of this context. And I'm going to import it, add it to the scope as well. And that's going to be context. Here we go. So I'm going to pass this as a parameter and that's going to return the value, the current value, which is passed down as a prop to the context object. So we're going to put a debugger to stop the app from running at line 49. I'm going to show you how it works. We're going to be able to see what's returning this value. So I'm going to open the console. And we're going to check, so when it stops, you're going to see that now when you pass here, the mouse-- now you see that you have access to this dispatch method and also the current state. Okay? 

So we're going to use that from now on instead of using this 'useReducer'. So I'm going to remove all of this. Here we go. And instead I'm going to replace, you know, like this value, we know that we have access. I'm going to specify the dispatch method and also the state, the current states. Here we go. And we no longer need this from here. Instead it's going to be implemented inside the context. 

So we're going to separate logic from the presentation. 

And now it's going to work the same way. So we can access the dispatch method to dispatch and send actions and then use the current state to then apply side effects and update the UI accordingly. So when there is a change in the states. So let's try that again. We're going to make another demo, so by trying to upload a new image. Let's try that. Here we go. We have a preview. Perfect. And we've been able to successfully add an image by using this time a global states. I mean, we are managing the state now globally, instead of doing it locally. So the exercise for you will be to do the same. You're going to do-- your task will be to subscribe every component to the global states, in order to then apply side effects and also allow to change the UI accordingly. So for example, you have the upload form, instead of passing data down by using the props. So in layout, we're going to check this out. You see that we've been passing data. So by going through the layout and again down to the upload form. So instead you want to allow the upload form to subscribe to the context changes. So that's going to be your exercise and we're going to look at the solutions together in the next video in order to manage the state globally with the context API.